{"version":3,"file":"66-mongodb.js","sources":["66-mongodb.ts"],"sourcesContent":["/**** some basic type definitions for safety (or for illustration) ****/\n\nimport {\n  Node,\n  NodeAPI,\n  NodeContext,\n  NodeCredentials,\n  NodeDef,\n  NodeMessageInFlow,\n} from \"node-red\";\n\n// interface nodeConfig extends NodeDef {\n//   user?: string;\n//   password?: string;\n//   hostname: string;\n//   port: string;\n//   db: string;\n//   name: string;\n//   connectOptions: string;\n//   topology: string;\n//   maxMsgLimit: number;\n// }\n\nimport { MongoClient } from \"mongodb\";\n\ninterface nodeMsg extends NodeMessageInFlow {\n  _queueCount?: number; // Stores the Current Queue Count of Msgs\n  queueCount?: boolean; // Flag to set QueueCount in  messages or not\n  reset?: boolean; // Reset the queue\n  bypassInterval?: string; //\n  bypass?: boolean;\n  trigger?: boolean;\n  req_failed?: boolean;\n  _queuetimestamp?: any; // Will be time stamp\n  ttl?: string;\n}\n\ninterface nodeContext extends Partial<NodeContext> {\n  queue: nodeMsg[];\n  backup_queue?: nodeMsg[];\n  is_disabled?: boolean;\n  capacity?: number;\n}\n\ninterface Creds {\n  user?: string;\n  password?: string;\n}\n\ninterface MongoNodeDef\n  extends Node<{\n    user?: string;\n    password?: string;\n  }> {\n  hostname?: string;\n  port?: string;\n  db?: string;\n  name?: string;\n  connectOptions?: string;\n  topology?: string;\n  maxMsgLimit?: number;\n  user?: string;\n  password?: string;\n  url: string;\n}\n\nmodule.exports = function (RED: NodeAPI) {\n  \"use strict\";\n  // var mongo = require(\"mongodb\");\n  var ObjectID = require(\"mongodb\").ObjectID;\n  // var MongoClient = mongo.MongoClient;\n\n  function MongoNode(this: MongoNodeDef, config: any) {\n    RED.nodes.createNode(this as Node, config);\n    this.hostname = config.hostname;\n    this.port = config.port;\n    this.db = config.db;\n    this.name = config.name;\n    this.connectOptions = config.connectOptions;\n    this.topology = config.topology;\n\n    //console.log(this);\n\n    var clustered = this.topology !== \"direct\" || false;\n\n    var url = \"mongodb://\";\n    if (this.topology === \"dnscluster\") {\n      url = \"mongodb+srv://\";\n    }\n    if (\n      this.credentials &&\n      this.credentials.user &&\n      this.credentials.password\n    ) {\n      this.user = this.credentials.user;\n      this.password = this.credentials.password;\n    } else {\n      this.user = config.user;\n      this.password = config.password;\n    }\n    if (this.user) {\n      url += this.user + \":\" + this.password + \"@\";\n    }\n    if (clustered) {\n      url += this.hostname + \"/\" + this.db;\n    } else {\n      url += this.hostname + \":\" + this.port + \"/\" + this.db;\n    }\n    if (this.connectOptions) {\n      url += \"?\" + this.connectOptions;\n    }\n\n    console.log(\"MongoDB URL: \" + url);\n    this.url = url;\n  }\n\n  RED.nodes.registerType<MongoNodeDef, NodeDef, {}, Creds>(\n    \"mongodb\",\n    MongoNode,\n    {\n      credentials: {\n        user: { type: \"text\" },\n        password: { type: \"password\" },\n      },\n    }\n  );\n\n  function ensureValidSelectorObject(selector: any) {\n    if (\n      selector != null &&\n      (typeof selector != \"object\" || Buffer.isBuffer(selector))\n    ) {\n      return {};\n    }\n    return selector;\n  }\n\n  interface MongoNodeOutDef extends Node {\n    collection?: string;\n    mongodb: string;\n    payonly?: boolean;\n    upsert?: boolean;\n    multi?: boolean;\n    operation?: string;\n    mongoConfig: MongoNodeDef;\n    client: any;\n    tout?: any;\n  }\n\n  interface MongoOutMsg extends NodeMessageInFlow {\n    collection?: string;\n    _topic?: string;\n    payload?: any;\n    _id?: string;\n    query?: any;\n    trigger?: boolean;\n  }\n  function MongoOutNode(this: MongoNodeOutDef, config: any) {\n    RED.nodes.createNode(this as Node, config);\n\n    this.collection = config.collection;\n    this.mongodb = config.mongodb;\n    this.payonly = config.payonly || false;\n    this.upsert = config.upsert || false;\n    this.multi = config.multi || false;\n    this.operation = config.operation;\n    this.mongoConfig = RED.nodes.getNode(this.mongodb) as MongoNodeDef;\n\n    this.status({\n      fill: \"grey\",\n      shape: \"ring\",\n      text: RED._(\"mongodb.status.connecting\"),\n    });\n    var node = this;\n\n    let client: MongoClient | null;\n\n    async function runs() {\n      client = new MongoClient(node.mongoConfig.url);\n      await client.connect();\n      // nodeContext.connection_up = true;\n      node.status({\n        fill: \"green\",\n        shape: \"dot\",\n        text: RED._(\"mongodb.status.connected\"),\n      });\n    }\n    runs().catch((err) => {\n      client = null;\n      // nodeContext.connection_up = false;\n      node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: RED._(\"mongodb.status.error\"),\n      });\n    });\n    console.log(\"OUTTTT WORKINGGG\");\n    node.on(\"input\", function (msg: MongoOutMsg, nodeSend, nodeDone) {\n      async function run(msg: MongoOutMsg) {\n        if (!client) {\n          client = new MongoClient(node.mongoConfig.url);\n          await client.connect();\n          node.status({\n            fill: \"green\",\n            shape: \"dot\",\n            text: RED._(\"mongodb.status.connected\"),\n          });\n        }\n        node.client = client;\n        var db = client.db();\n        var coll;\n\n        if (node.collection) {\n          coll = db.collection(node.collection);\n        }\n\n        if (!node.collection) {\n          if (msg.collection) {\n            coll = db.collection(msg.collection);\n          } else {\n            nodeDone(Error(RED._(\"mongodb.errors.nocollection\")));\n          }\n        }\n        delete msg._topic;\n        delete msg.collection;\n        if (coll) {\n          if (node.operation === \"insert\") {\n            if (node.payonly) {\n              if (typeof msg.payload !== \"object\") {\n                msg.payload = { payload: msg.payload };\n              }\n              if (\n                msg.hasOwnProperty(\"_id\") &&\n                !msg.payload.hasOwnProperty(\"_id\")\n              ) {\n                msg.payload._id = msg._id;\n              }\n              await coll.insertOne(msg.payload);\n            } else {\n              await coll.insertOne(msg as any);\n            }\n          } else if (node.operation === \"update\") {\n            if (typeof msg.payload !== \"object\") {\n              msg.payload = { payload: msg.payload };\n            }\n            var query = msg.query || {};\n            var payload = msg.payload || {};\n            var options = {\n              upsert: node.upsert,\n              multi: node.multi,\n            };\n            if (ObjectID.isValid(msg.query._id)) {\n              msg.query._id = new ObjectID(msg.query._id);\n            }\n            await coll.updateOne(query, payload, options);\n          } else if (node.operation === \"delete\") {\n            await coll.deleteOne(msg.payload);\n          }\n        }\n        msg.payload = \"success\";\n        msg.trigger = true;\n        node.send([msg, null]);\n        nodeDone();\n      }\n\n      run(msg).catch((e) => {\n        console.log(\"=================ERROR=====================\");\n        console.log(e);\n        console.log(\"=================ERROR=====================\");\n        // runs().catch(()=>{});;\n        // client = null;\n        node.status({\n          fill: \"red\",\n          shape: \"ring\",\n          text: RED._(\"mongodb.status.error\"),\n        });\n        // msg.error = \"Couldn't not connect to mongodb\"\n        let error_msg = msg as any;\n        error_msg.error = e;\n        node.send([null, error_msg]);\n        // msg.error = e;\n        nodeDone(Error(e));\n        // nodeDone(msg.error, msg);\n      });\n    });\n\n    node.on(\"close\", function () {\n      node.status({});\n      if (node.tout) {\n        clearTimeout(node.tout);\n      }\n      if (node.client) {\n        node.client.close();\n      }\n    });\n  }\n  RED.nodes.registerType(\"mongodb out\", MongoOutNode);\n\n  interface MongoNodeInDef extends Node {\n    collection?: string;\n    mongodb: string;\n    operation?: string;\n    mongoConfig: MongoNodeDef;\n    client: any;\n    tout?: any;\n  }\n\n  interface MongoInMsg extends NodeMessageInFlow {\n    projection?: string;\n    limit?: any;\n    skip?: any;\n    sort?: any;\n    collection?: string;\n    _topic?: string;\n    payload?: any;\n    _id?: string;\n    query?: any;\n    trigger?: boolean;\n  }\n  function MongoInNode(this: MongoNodeInDef, config: any) {\n    RED.nodes.createNode(this, config);\n    this.collection = config.collection;\n    this.mongodb = config.mongodb;\n    this.operation = config.operation || \"find\";\n    this.mongoConfig = RED.nodes.getNode(this.mongodb) as MongoNodeDef;\n    this.status({\n      fill: \"grey\",\n      shape: \"ring\",\n      text: RED._(\"mongodb.status.connecting\"),\n    });\n    var node = this;\n    var noerror = true;\n\n    var client :MongoClient | null = null;\n    async function run() {\n      client = new MongoClient(node.mongoConfig.url);\n      await client.connect();\n      node.status({\n        fill: \"green\",\n        shape: \"dot\",\n        text: RED._(\"mongodb.status.connected\"),\n      });\n    }\n    run().catch((err) => {\n      client = null;\n      node.status({\n        fill: \"red\",\n        shape: \"ring\",\n        text: RED._(\"mongodb.status.error\"),\n      });\n    });\n\n    node.on(\"input\", function (msg :MongoInMsg, nodeSend, nodeDone) {\n      async function run(msg :MongoInMsg) {\n        if (!client) {\n          client = new MongoClient(node.mongoConfig.url);\n          await client.connect();\n          node.status({\n            fill: \"green\",\n            shape: \"dot\",\n            text: RED._(\"mongodb.status.connected\"),\n          });\n        }\n        node.client = client;\n        var db = client.db();\n        var coll;\n\n        if (!node.collection) {\n          if (msg.collection) {\n            coll = db.collection(msg.collection);\n          } else {\n            node.error(RED._(\"mongodb.errors.nocollection\"));\n            return;\n          }\n        } else {\n          coll = db.collection(node.collection);\n        }\n        var selector:any;\n        if (node.operation === \"find\") {\n          let projection = msg.projection || {};\n          selector = ensureValidSelectorObject(msg.payload);\n          let limit = msg.limit;\n          if (typeof limit === \"string\" && !isNaN(+limit)) {\n            limit = Number(limit);\n          } else if (typeof limit === \"undefined\") {\n            limit = 0;\n          }\n          var skip = msg.skip;\n          if (typeof skip === \"string\" && !isNaN(+skip)) {\n            skip = Number(skip);\n          } else if (typeof skip === \"undefined\") {\n            skip = 0;\n          }\n\n           coll\n            .find(selector)\n            .project(projection)\n            .sort(msg.sort)\n            .limit(limit)\n            .skip(skip)\n            .toArray( (err:any, items:any) =>{\n              if (err) {\n                \n                node.error(err, msg);\n              } else {\n                msg.payload = items;\n                delete msg.projection;\n                delete msg.sort;\n                delete msg.limit;\n                delete msg.skip;\n                node.send(msg);\n              }\n            });\n        } else if (node.operation === \"count\") {\n          selector = ensureValidSelectorObject(msg.payload);\n          coll.count(selector,function (err: any, count: any) {\n            if (err) {\n              node.error(err, msg);\n            } else {\n              msg.payload = count;\n              node.send(msg);\n            }\n          });\n        } else if (node.operation === \"aggregate\") {\n          msg.payload = Array.isArray(msg.payload) ? msg.payload : [];\n          let cursor = coll.aggregate(msg.payload);\n          cursor.toArray(function (\n            cursorError: any,\n            cursorDocs: any\n          ) {\n            //console.log(cursorDocs);\n            if (cursorError) {\n              node.error(cursorError, msg);\n            } else {\n              msg.payload = cursorDocs;\n              node.send(msg);\n            }\n          });\n          \n        }\n      }\n\n      run(msg).catch((e) => {\n        console.log(e);\n        // client.close();\n        client = null;\n        node.status({\n          fill: \"red\",\n          shape: \"ring\",\n          text: RED._(\"mongodb.status.error\"),\n        });\n        let error_msg = msg as any;\n        error_msg.error = \"Couldn't not connect to mongodb\";\n        node.send([null, error_msg]);\n        nodeDone(e);\n      });\n    });\n\n    // var connectToDB = function () {\n    //   console.log(\"connecting:  \" + node.mongoConfig.url);\n    //   MongoClient.connect(\n    //     node.mongoConfig.url,\n    //     function (err: any, client: any) {\n    //       if (err) {\n    //         console.log(\"ERROR FOUND\");\n    //         node.on(\"input\", function (msg, nodeSend, nodeDone) {\n    //           let error_msg = msg as any;\n    //           error_msg.error = err;\n    //           node.send([null, msg]);\n    //           // msg.error = e;\n    //           nodeDone(Error(err));\n    //         });\n    //         node.status({\n    //           fill: \"red\",\n    //           shape: \"ring\",\n    //           text: RED._(\"mongodb.status.error\"),\n    //         });\n    //         if (noerror) {\n    //           console.log(\"NOERRROR\");\n    //           node.error(err);\n    //         }\n    //         noerror = false;\n    //         node.tout = setTimeout(connectToDB, 10000);\n    //       } else {\n    //         node.status({\n    //           fill: \"green\",\n    //           shape: \"dot\",\n    //           text: RED._(\"mongodb.status.connected\"),\n    //         });\n    //         node.client = client;\n    //         var db = client.db();\n    //         noerror = true;\n    //         var coll;\n    //         node.on(\"input\", function (msg: MongoInMsg, nodeSend, done) {\n    //           if (!node.collection) {\n    //             if (msg.collection) {\n    //               coll = db.collection(msg.collection);\n    //             } else {\n    //               node.error(RED._(\"mongodb.errors.nocollection\"), msg);\n    //               return;\n    //               // return done();\n    //             }\n    //           } else {\n    //             coll = db.collection(node.collection);\n    //           }\n    //           var selector;\n    //           if (node.operation === \"find\") {\n    //             let projection = msg.projection || {};\n    //             selector = ensureValidSelectorObject(msg.payload);\n    //             let limit = msg.limit;\n    //             if (typeof limit === \"string\" && !isNaN(+limit)) {\n    //               limit = Number(limit);\n    //             } else if (typeof limit === \"undefined\") {\n    //               limit = 0;\n    //             }\n    //             var skip = msg.skip;\n    //             if (typeof skip === \"string\" && !isNaN(+skip)) {\n    //               skip = Number(skip);\n    //             } else if (typeof skip === \"undefined\") {\n    //               skip = 0;\n    //             }\n\n    //             coll\n    //               .find(selector)\n    //               .project(msg.projection)\n    //               .sort(msg.sort)\n    //               .limit(limit)\n    //               .skip(skip)\n    //               .toArray(function (err: any, items: any) {\n    //                 if (err) {\n    //                   node.error(err, msg);\n    //                 } else {\n    //                   msg.payload = items;\n    //                   delete msg.projection;\n    //                   delete msg.sort;\n    //                   delete msg.limit;\n    //                   delete msg.skip;\n    //                   node.send(msg);\n    //                 }\n    //               });\n    //           } else if (node.operation === \"count\") {\n    //             selector = ensureValidSelectorObject(msg.payload);\n    //             coll.count(selector, function (err: any, count: any) {\n    //               if (err) {\n    //                 node.error(err, msg);\n    //               } else {\n    //                 msg.payload = count;\n    //                 node.send(msg);\n    //               }\n    //             });\n    //           } else if (node.operation === \"aggregate\") {\n    //             msg.payload = Array.isArray(msg.payload) ? msg.payload : [];\n    //             coll.aggregate(msg.payload, function (err: any, cursor: any) {\n    //               if (err) {\n    //                 node.error(err, msg);\n    //               } else {\n    //                 cursor.toArray(function (\n    //                   cursorError: any,\n    //                   cursorDocs: any\n    //                 ) {\n    //                   //console.log(cursorDocs);\n    //                   if (cursorError) {\n    //                     node.error(cursorError, msg);\n    //                   } else {\n    //                     msg.payload = cursorDocs;\n    //                     node.send(msg);\n    //                   }\n    //                 });\n    //               }\n    //             });\n    //           }\n    //         });\n    //       }\n    //     }\n    //   );\n    // };\n\n    // if (node.mongoConfig) {\n    //   connectToDB();\n    // } else {\n    //   node.error(RED._(\"mongodb.errors.missingconfig\"));\n    // }\n\n    node.on(\"close\", function () {\n      node.status({});\n      if (node.tout) {\n        clearTimeout(node.tout);\n      }\n      if (node.client) {\n        node.client.close();\n      }\n    });\n  }\n  RED.nodes.registerType(\"mongodb in\", MongoInNode);\n};\n"],"names":["mongodb_1","require","module","exports","RED","ObjectID","ensureValidSelectorObject","selector","Buffer","isBuffer","nodes","registerType","config","createNode","this","hostname","port","db","name","connectOptions","topology","clustered","url","credentials","user","password","console","log","type","collection","mongodb","payonly","upsert","multi","operation","mongoConfig","getNode","status","fill","shape","text","_","node","client","async","MongoClient","connect","runs","catch","err","on","msg","nodeSend","nodeDone","coll","Error","_topic","payload","hasOwnProperty","_id","insertOne","query","options","isValid","updateOne","deleteOne","trigger","send","run","e","error_msg","error","tout","clearTimeout","close","projection","limit","isNaN","Number","skip","find","project","sort","toArray","items","count","Array","isArray","aggregate","cursorError","cursorDocs"],"mappings":"oEAuBA,MAAsCA,EAAAC,QAAA,WA2CtCC,OAAOC,QAAU,SAAUC,GAGzB,IAAIC,EAAWJ,QAAQ,WAAWI,SA0DlC,SAASC,EAA0BC,GACjC,OACc,MAAZA,GACoB,iBAAZA,IAAwBC,OAAOC,SAASF,GAI3CA,EAFE,GAhBXH,EAAIM,MAAMC,aACR,WA7CF,SAAuCC,GACrCR,EAAIM,MAAMG,WAAWC,KAAcF,GACnCE,KAAKC,SAAWH,EAAOG,SACvBD,KAAKE,KAAOJ,EAAOI,KACnBF,KAAKG,GAAKL,EAAOK,GACjBH,KAAKI,KAAON,EAAOM,KACnBJ,KAAKK,eAAiBP,EAAOO,eAC7BL,KAAKM,SAAWR,EAAOQ,SAIvB,IAAIC,EAA8B,WAAlBP,KAAKM,WAAyB,EAE1CE,EAAM,aACY,eAAlBR,KAAKM,WACPE,EAAM,kBAGNR,KAAKS,aACLT,KAAKS,YAAYC,MACjBV,KAAKS,YAAYE,UAEjBX,KAAKU,KAAOV,KAAKS,YAAYC,KAC7BV,KAAKW,SAAWX,KAAKS,YAAYE,WAEjCX,KAAKU,KAAOZ,EAAOY,KACnBV,KAAKW,SAAWb,EAAOa,UAErBX,KAAKU,OACPF,GAAOR,KAAKU,KAAO,IAAMV,KAAKW,SAAW,KAGzCH,GADED,EACKP,KAAKC,SAAW,IAAMD,KAAKG,GAE3BH,KAAKC,SAAW,IAAMD,KAAKE,KAAO,IAAMF,KAAKG,GAElDH,KAAKK,iBACPG,GAAO,IAAMR,KAAKK,gBAGpBO,QAAQC,IAAI,gBAAkBL,GAC9BR,KAAKQ,IAAMA,IAMX,CACEC,YAAa,CACXC,KAAM,CAAEI,KAAM,QACdH,SAAU,CAAEG,KAAM,eA8KxBxB,EAAIM,MAAMC,aAAa,eA3IvB,SAA6CC,GAC3CR,EAAIM,MAAMG,WAAWC,KAAcF,GAEnCE,KAAKe,WAAajB,EAAOiB,WACzBf,KAAKgB,QAAUlB,EAAOkB,QACtBhB,KAAKiB,QAAUnB,EAAOmB,UAAW,EACjCjB,KAAKkB,OAASpB,EAAOoB,SAAU,EAC/BlB,KAAKmB,MAAQrB,EAAOqB,QAAS,EAC7BnB,KAAKoB,UAAYtB,EAAOsB,UACxBpB,KAAKqB,YAAc/B,EAAIM,MAAM0B,QAAQtB,KAAKgB,SAE1ChB,KAAKuB,OAAO,CACVC,KAAM,OACNC,MAAO,OACPC,KAAMpC,EAAIqC,EAAE,+BAEd,IAAIC,EAAO5B,KAEX,IAAI6B,GAEJC,iBACED,EAAS,IAAI3C,EAAA6C,YAAYH,EAAKP,YAAYb,WACpCqB,EAAOG,UAEbJ,EAAKL,OAAO,CACVC,KAAM,QACNC,MAAO,MACPC,KAAMpC,EAAIqC,EAAE,+BAGhBM,GAAOC,OAAOC,IACZN,EAAS,KAETD,EAAKL,OAAO,CACVC,KAAM,MACNC,MAAO,OACPC,KAAMpC,EAAIqC,EAAE,6BAGhBf,QAAQC,IAAI,oBACZe,EAAKQ,GAAG,SAAS,SAAUC,EAAkBC,EAAUC,IACrDT,eAAmBO,GACZR,IACHA,EAAS,IAAI3C,EAAA6C,YAAYH,EAAKP,YAAYb,WACpCqB,EAAOG,UACbJ,EAAKL,OAAO,CACVC,KAAM,QACNC,MAAO,MACPC,KAAMpC,EAAIqC,EAAE,+BAGhBC,EAAKC,OAASA,EACd,IACIW,EADArC,EAAK0B,EAAO1B,KAgBhB,GAbIyB,EAAKb,aACPyB,EAAOrC,EAAGY,WAAWa,EAAKb,aAGvBa,EAAKb,aACJsB,EAAItB,WACNyB,EAAOrC,EAAGY,WAAWsB,EAAItB,YAEzBwB,EAASE,MAAMnD,EAAIqC,EAAE,yCAGlBU,EAAIK,cACJL,EAAItB,WACPyB,EACF,GAAuB,WAAnBZ,EAAKR,UACHQ,EAAKX,SACoB,iBAAhBoB,EAAIM,UACbN,EAAIM,QAAU,CAAEA,QAASN,EAAIM,UAG7BN,EAAIO,eAAe,SAClBP,EAAIM,QAAQC,eAAe,SAE5BP,EAAIM,QAAQE,IAAMR,EAAIQ,WAElBL,EAAKM,UAAUT,EAAIM,gBAEnBH,EAAKM,UAAUT,QAElB,GAAuB,WAAnBT,EAAKR,UAAwB,CACX,iBAAhBiB,EAAIM,UACbN,EAAIM,QAAU,CAAEA,QAASN,EAAIM,UAE/B,IAAII,EAAQV,EAAIU,OAAS,GACrBJ,EAAUN,EAAIM,SAAW,GACzBK,EAAU,CACZ9B,OAAQU,EAAKV,OACbC,MAAOS,EAAKT,OAEV5B,EAAS0D,QAAQZ,EAAIU,MAAMF,OAC7BR,EAAIU,MAAMF,IAAM,IAAItD,EAAS8C,EAAIU,MAAMF,YAEnCL,EAAKU,UAAUH,EAAOJ,EAASK,OACT,WAAnBpB,EAAKR,iBACRoB,EAAKW,UAAUd,EAAIM,SAG7BN,EAAIM,QAAU,UACdN,EAAIe,SAAU,EACdxB,EAAKyB,KAAK,CAAChB,EAAK,OAChBE,KAGFe,CAAIjB,GAAKH,OAAOqB,IACd3C,QAAQC,IAAI,+CACZD,QAAQC,IAAI0C,GACZ3C,QAAQC,IAAI,+CAGZe,EAAKL,OAAO,CACVC,KAAM,MACNC,MAAO,OACPC,KAAMpC,EAAIqC,EAAE,0BAGd,IAAI6B,EAAYnB,EAChBmB,EAAUC,MAAQF,EAClB3B,EAAKyB,KAAK,CAAC,KAAMG,IAEjBjB,EAASE,MAAMc,UAKnB3B,EAAKQ,GAAG,SAAS,WACfR,EAAKL,OAAO,IACRK,EAAK8B,MACPC,aAAa/B,EAAK8B,MAEhB9B,EAAKC,QACPD,EAAKC,OAAO+B,cA6SlBtE,EAAIM,MAAMC,aAAa,cAlRvB,SAA2CC,GACzCR,EAAIM,MAAMG,WAAWC,KAAMF,GAC3BE,KAAKe,WAAajB,EAAOiB,WACzBf,KAAKgB,QAAUlB,EAAOkB,QACtBhB,KAAKoB,UAAYtB,EAAOsB,WAAa,OACrCpB,KAAKqB,YAAc/B,EAAIM,MAAM0B,QAAQtB,KAAKgB,SAC1ChB,KAAKuB,OAAO,CACVC,KAAM,OACNC,MAAO,OACPC,KAAMpC,EAAIqC,EAAE,+BAEd,IAAIC,EAAO5B,KAGP6B,EAA6B,MACjCC,iBACED,EAAS,IAAI3C,EAAA6C,YAAYH,EAAKP,YAAYb,WACpCqB,EAAOG,UACbJ,EAAKL,OAAO,CACVC,KAAM,QACNC,MAAO,MACPC,KAAMpC,EAAIqC,EAAE,+BAGhB2B,GAAMpB,OAAOC,IACXN,EAAS,KACTD,EAAKL,OAAO,CACVC,KAAM,MACNC,MAAO,OACPC,KAAMpC,EAAIqC,EAAE,6BAIhBC,EAAKQ,GAAG,SAAS,SAAUC,EAAiBC,EAAUC,IACpDT,eAAmBO,GACZR,IACHA,EAAS,IAAI3C,EAAA6C,YAAYH,EAAKP,YAAYb,WACpCqB,EAAOG,UACbJ,EAAKL,OAAO,CACVC,KAAM,QACNC,MAAO,MACPC,KAAMpC,EAAIqC,EAAE,+BAGhBC,EAAKC,OAASA,EACd,IACIW,EAYA/C,EAbAU,EAAK0B,EAAO1B,KAGhB,GAAKyB,EAAKb,WAQRyB,EAAOrC,EAAGY,WAAWa,EAAKb,gBARN,CACpB,IAAIsB,EAAItB,WAIN,YADAa,EAAK6B,MAAMnE,EAAIqC,EAAE,gCAFjBa,EAAOrC,EAAGY,WAAWsB,EAAItB,YAS7B,GAAuB,SAAnBa,EAAKR,UAAsB,CAC7B,IAAIyC,EAAaxB,EAAIwB,YAAc,GACnCpE,EAAWD,EAA0B6C,EAAIM,SACzC,IAAImB,EAAQzB,EAAIyB,MACK,iBAAVA,GAAuBC,OAAOD,QAEb,IAAVA,IAChBA,EAAQ,GAFRA,EAAQE,OAAOF,GAIjB,IAAIG,EAAO5B,EAAI4B,KACK,iBAATA,GAAsBF,OAAOE,QAEb,IAATA,IAChBA,EAAO,GAFPA,EAAOD,OAAOC,GAKfzB,EACE0B,KAAKzE,GACL0E,QAAQN,GACRO,KAAK/B,EAAI+B,MACTN,MAAMA,GACNG,KAAKA,GACLI,SAAS,CAAClC,EAASmC,KACdnC,EAEFP,EAAK6B,MAAMtB,EAAKE,IAEhBA,EAAIM,QAAU2B,SACPjC,EAAIwB,kBACJxB,EAAI+B,YACJ/B,EAAIyB,aACJzB,EAAI4B,KACXrC,EAAKyB,KAAKhB,YAGX,GAAuB,UAAnBT,EAAKR,UACd3B,EAAWD,EAA0B6C,EAAIM,SACzCH,EAAK+B,MAAM9E,GAAS,SAAU0C,EAAUoC,GAClCpC,EACFP,EAAK6B,MAAMtB,EAAKE,IAEhBA,EAAIM,QAAU4B,EACd3C,EAAKyB,KAAKhB,YAGT,GAAuB,cAAnBT,EAAKR,UAA2B,CACzCiB,EAAIM,QAAU6B,MAAMC,QAAQpC,EAAIM,SAAWN,EAAIM,QAAU,GAC5CH,EAAKkC,UAAUrC,EAAIM,SACzB0B,SAAQ,SACbM,EACAC,GAGID,EACF/C,EAAK6B,MAAMkB,EAAatC,IAExBA,EAAIM,QAAUiC,EACdhD,EAAKyB,KAAKhB,SAOlBiB,CAAIjB,GAAKH,OAAOqB,IACd3C,QAAQC,IAAI0C,GAEZ1B,EAAS,KACTD,EAAKL,OAAO,CACVC,KAAM,MACNC,MAAO,OACPC,KAAMpC,EAAIqC,EAAE,0BAEd,IAAI6B,EAAYnB,EAChBmB,EAAUC,MAAQ,kCAClB7B,EAAKyB,KAAK,CAAC,KAAMG,IACjBjB,EAASgB,SAiIb3B,EAAKQ,GAAG,SAAS,WACfR,EAAKL,OAAO,IACRK,EAAK8B,MACPC,aAAa/B,EAAK8B,MAEhB9B,EAAKC,QACPD,EAAKC,OAAO+B"}